### ch3. 타입스크립트에서 사용할 수 있는 타입은? 각각의 타입으로 무엇을 할 수 있을까?

타입 검사기(typechecker)를 이용해 유효하지 않는 동작이 실행되는 일을 예방하자.

<img src = "./typelevel.jpg"/>

##### 타입스크립트 Type의 종류
###### any
- 꼭 필요한 상황이 아니라면 사용하지 않는 것이 좋다.<br />
- any를 사용하면 값이 js처럼 동작하면서, 타입검사기가 작동하지 않는다.

###### unknown
- 타입을 미리 알 수 없는 어떤 값이 있을 때, any대신 unknown을 사용
- 비교연산(==, ===, ||, &&, ?)과 반전(!)을 지원
- js의 typeof, instanceof 연산자로 정제할 수 있다.
- 명시적으로 설정해야만 사용 가능
- unknown 타입이 아닌 값과 unknown 타입인 값을 비교할 수 있다.


###### boolean
- true, false 2개의 값
- 비교 연산(==, ===, ||, &&, ?)과 반전(!) 연산만 가능<br />

예시<br />
let a = true  // boolean<br />
var b = false // boolean<br />
주로 위와 같은 방법으로 사용한다.<br />

예시<br />
let e: true = true   // true<br />
변수 e는 평범한 boolean이 아니라, boolean true라는 특정 타입을 갖고있다.<br />
값을 타입으로 사용하므로, e에 사용할 ㅅ ㅜ있는 값은 boolean타입이 가질 수 있는 값 중 특정한 하나의 값으로 한정된다. 이 기능을 "타입 리터럴"이라 부른다.<br />

- 타입 리터럴이란?
오직 하나의 값을 나타내는 타입<br />

###### number
- 모든 숫자(정수, 소수, 양수, 음수, Infinity NaN 등)의 집합
- 덧셈(+), 뺄셈(-), %, 비교(<) 등의 숫자 관련 연산
- 명시적으로 지정해도 되고, 추론하게 해도 된다.
- 보통은 타입스크립트가 값이 number임을 추론하게 한다. (let a = 1234)

###### bigint
- 2^53보다 큰 정수를 표현할 수 있다.
- 덧셈, 뺄셈, 곱셈, 나눗셈, 비교 연산
- 가능하면 타입스크립트가 추론하게 만들자.

###### string
- 모든 문자열의 집합
- 연결(+), 슬라이스(.slice) 등의 연산 수행
- 가능하면 타입스크립트가 추론하게 만들자.


###### symbol
- 실무에서는 자주 사용하지 않는 편
- 객체와 맵에서, 문자열 키를 대신하는 용도로 사용
- symbol 타입으로는 할 수 있는 동작이 별로 없다.
```
let a = Symbol('a')   // symbol
let b: symbol = Symbol('b')  // symbol
var c = a === b   // boolean
```
- unique symbol 만드는 법


###### 객체
- ts로 객체를 정의하는 방법은 총 4가지이다. (p34)
- 객체 타입만으로는 {}로 만든 간단한 객체와, new로 만든 복잡한 객체를 구분할 수 없다<br />
```
let a: object = { b: 'x'}
```
여기서 a.b에는 접근할 수 없다.(에러)

- 객체를 만드는 또다른 방법: 객체 리터럴 문법 (타입스크립트가 추론하도록)
```
let a: { b: number } = {
    b: 12
}  // {b: number}
```

- 객체를 const로 선언하느냐/ let으로 선언하느냐에 따른 차이 (p30)

- 확실한 할당

- 인덱스 시그니처<br />
[key: T]: U 같은 문법. ts에 어떤 객체가 여러 키를 가질 수 있다.<br />
인덱스 시그니처의 키(T)는 반드시 number나 string타입에 할당할 수 있는 값이어야한다.

- 객체: Object로 객체 타입을 만드는 방법도 있지만, {}와 비슷한 방법이며, 추천하지 않는다.

###### 타입 별칭, 유니온, 인터섹션
값뿐만 아니라 타입에도 어떤 동작을 수행할 수 있다. 타입수준에서 수행할 수 있는 몇가지 동작<br />

- 타입 별칭 (타입 별칭으로 타입을 가리킬 수 있다.)<br />
변수가 어떤 목적으로 사용됐는지 쉽게 이해할 수 있게 도와준다.<br />
값을 변수로 할당할지를 결정하는 것과 같은 기준으로, 타입 별칭을 사용할지 여부를 결정할 수 있다.<br />

- 유니온과 인터섹션 타입<br />
실무에서는 인터섹션보다 "유니온"을 자주 사용<br />
"유니온"은 이형(heterogeneous) 배열일 때 자주 등장<br />

###### 배열
- 연결, 푸시, 검색, 슬라이스 등을 지원하는 특별한 객체
- 배열에 무엇을 넣을 수 있고, 무엇을 넣을 수 없는지에 대한 규칙이 있다.
- 대부분 동형(homogeneous)으로 배열을 만든다.
- 타입스크립트에서는 T[]와 Array`<T>`라는 2가지 배열 문법 지원 (성능, 의미상 두 표현은 같다.)
<br />

###### 튜플
- 배열의 서브타입
- 길이가 고정되었고, 각 인덱스의 타입이 알려진 배열의 일종
- 다른 타입과 달리, 튜플은 선언할 때 타입을 명시해야한다.
```
// [이름, 성씨, 생년] 튜플
let b: [string, string, number] = ['malcolm', 'gladwell', 1963]
```
<br />

- 읽기 전용 배열과 튜플<br />
ts는 Array처럼 읽기 전용 배열과 튜플을 만드는 긴 형태의 선언 방법을 지원한다.<br />
```
type A = readonly string[]  // readonly string[]
type B = ReadonlyArray <string>  // readonly string[]
type C = Readonly<string[]>  // readonly string[]

type D = readonly [number,string]  // readonly [number,string]
type E = Readonly<[number, string]> // readonly [number,string]
```
<br />


###### null, undefined, void, never
ts에서 undefined 값의 타입은 오직 undefined뿐이고, <br />null 값의 타입은 null뿐이다.<br />
- ts에서는 null과 undefined 이외에도 void와 never 타입도 제공한다.
- void와 never은 존재하지 않음의 특징을 좀 더 세밀하게 분류 (특별한 용도의 타입)
void: 명시적으로 아무것도 반환하지 않는 함수의 반환타입 (예: console.log)<br />
never: 절대 반환하지 않는 (예외를 던지거나 영원히 실행되는) 함수 타입<br />
- null: 값이 없음, undefined: 아직 값을 변수에 할당하지 않음

- 엄격한 null 확인

###### 열거형 (enum)
- 해당 타입으로 사용할 수 있는 값을 열거하는 기법
- 키를 값에 할당하는, 순서가 없는 자료구조
```
enum Language {
    English, Spanish, Russian
}
```

- 열거형을 안전하게 사용하기 힘드므로, 열거형 자체를 사용하지 않는 것을 추천


###### 마무리
- ts가 값의 타입을 추론하거나 / 타입을 명시할 수 있다.
- let과 var를 사용하면 일반적인 타입으로 추론하는 반면,<br />
- const를 사용하면 더 구체적인 타입을 추론하게 만든다.<br />
- 대부분의 타입은 일반 타입 / 구체적인 타입 2가지 제공<br />
구체적 타입은 보통 일반 타입의 서브타입