# 내용 정리

## 1장 소개

### 소개

- 타입스크립트는 흔히 발생하는 실수를 방지하며, 자신과 미래의 개발자들에게 문서화를 제공하고, 리팩토리링을 쉽게 만들며, 단위 테스트의 숫자를 반으로 줄임으로서 더 **안전한** 프로그램을 구현할 수 있게 보장한다.
- 여기서 안전한의 의미는 타입 안전성을 뜻한다.
  - 타입 안전성: 타입을 이용해 프로그램이 유효하지 않은 작업을 수행하지 않도록 방지
- 자바스크립트는 타입을 보장해 주지 않아도 실행하는 데에 애쓴다. 이는 예외 발생에 적극적이지 않다는 단점이 있다.

## 2장 타입스크립트: 3,000 미터 상공에서 내려다보기

### 컴파일러

- 개발자가 작성한 코드를 컴퓨터가 이해할 수 있는 코드로 변환하는 작업을 컴파일이라고 한다. 대부분의 언어는 다음과 같은 과정을 거친다.
  - **프로그램이 AST(추상 문법 트리)로 파싱 > AST가 바이트코드로 컴파일 > 런타임이 바이트코드로 평가**
- 이때, 타입스크립트는 바이트코드로 변환하는 것이 아닌 자바스크립트 코드로 변환된다. 그 이전에 타입스크립트는 AST를 만들고 나서 타입 검사기를 통해 타입 확인을 거친다.
- 타입스크립트 AST가 자바스크립트로 변환할 때에는 개발자가 사용한 타입을 확인하지 않는다. 즉, 개발자가 입력한 타입 정보는 최종 프로그램에 아무런 영향을 끼치지 않으며 타입 확인하는 데에만 쓰인다.

### 타입 시스템

- 타입 시스템이란 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합이다. 이러한 타입 시스템은 타입을 컴파일러에게 **명시적으로 알려주는 시스템**과 타입을 **추론할 수 있는 시스템**으로 나눌 수 있다.
- 그렇다면, 타입은 언제 결정되는가?
  - 자바스크립트는 동적 타입 바인딩으로서 프로그램을 실행해야만 타입을 알 수 있다. 반면 타입스크립트는 점진적으로 타입을 확인하는 언어이다. 즉, 타입을 지정하지 않는 프로그램이더라도 일부 추론해서 오류를 검출할 수도 있지만 모든 타입을 알지 못하는 상황에서는 많은 오류가 사용자에게 그대로 노출할 수 있다.

## 3장 타입의 모든 것

### 타입을 이야기하다

- 타입 어노테이션이 없으면 함수의 매개변수에 제한이 없으므로 아무 타입이나 인수로 전달될 수 있다. 함수의 인자에 타입을 제한하면 타입스크립트가 함수를 호출할 때 호환이 되는 인수로 호출했는지 판단한다.

### any

- any는 모든 값의 집합(타입)이므로 무엇이든 할 수 있지만, 꼭 필요한 상황이 아니라면 사용하지 않는 것이 좋다.
- any를 사용하면 값이 자바스크립트처럼 동작하기 시작하면서 타입 검사기의 의미가 사라진다.

### unknown

- 타입을 미리 알 수 없는 값이 있을 때 any 대신 사용할 수 있다. 왜냐하면 타입을 검사해 정제하기 전까지 타입스크립트가 해당 타입의 값을 사용할 수 없게 강제하기 때문이다.
  - 즉, unknown 으로 정의했는데 이를 연산한다는지 등 사용할 수 없다. 만약 사용하고 싶으면 if 문 등을 통해 해당 타입을 검증하고 사용해야 한다.
- 타입스크립트가 unknown 으로 추론하는 일은 없다. 개발자가 정의해야 한다.

### boolean

- boolean은 true와 false 두 개의 값을 갖는다.
- 타입 리터럴은 다음과 같이 오직 하나의 값을 나타내는 타입이다. 즉, 모든 곳에서 일어날 수 있는 실수를 방지해 안전성을 추가로 확보해주는 강력한 언어 기능이다.

```
let f: true = true;
```

### number

- 만약 긴 숫자를 처리하고 싶을 땐 숫자 분리자를 사용할 수 있ㄷ다.
  - 1000000 = 1_000_000(타입에도 사용할 수 있음)

### bigInt

- 큰 정수를 처리하기 위한 타입이다. 가능하면 타입스크립트가 이 타입을 추론하게 만들자.

### string

- 가능하면 타입스크립트가 이 타입을 추론하게 만들자.

### symbol

- 심볼은 유니크한 값이기 때문에 const 변수에 할당하면 `unique symbol` 타입으로 추론한다.

### object

- 일반적으로 const 와 let으로 사용함에 따라 타입스크립트가 타입을 추론하는지 다르다. 다만, object에서는 const로 선언을 해도 타입스크립트가 더 좁은 타입으로 추론하지 않는다. 객체의 값을 바뀔 수 있기 때문이다.
- 기본적으로 타입스크립트는 객체 프로퍼티에 엄격하다. 프로퍼티와 타입을 정의하면 정의한 프로퍼티 값만 있어야만 한다. 이러한 엄격한 프로퍼티 제한을 선택적으로 하는 방법은 ?를 붙여줌으로서 해결할 수 있다.
- readonly 한정자를 통해 읽기 전용으로 정의할 수 있다. (초깃값을 할당한 다음에 그 값을 바꿀 수 없는 방법)
- 빈 객체로 정의하는 건 피하는 것이 좋다.

### 타입 별칭, 유니온, 인터섹션

- 타입 별칭
  - const, let으로 변수를 선언하듯 타입별칭으로 타입을 가리킬 수 있다.
  - 타입스크립트는 별칭을 추론하지 않으니 명시적으로 정의해야한다.
  - let과 const 처럼 하나의 타입을 두 번 정의할 수 없으며 블록 영역에 적용된다.
  - 이는 복잡한 타입을 반복하지 않게 해주며 어떤 목적으로 사용되었는지 이해할 수 있게 해준다.
- 유니온과 인터섹션 타입
  - 집합으로 치자면 유니온(|)은 합집합, 인터섹션(&)은 교집합이다.
  - 유니온에 사용된 값이 꼭 유니온을 구성하는 타입 중 하나일 필요는 없다. 양쪽 모두에 속할 수 있다.

### 배열

- 배열을 나타내는 방법은 T[]와 Array<T> 방법이 있다.

### 튜플

- 튜플은 길이가 고정되었고, 각 인덱스의 타입이 알려진 배열의 일종이다. 튜플은 다른 타입과 달리 타입을 명시해야 한다. 타입스크립트에서는 대괄호를 배열 타입으로 추론하기 때문에 튜플을 사용하기 위해서는 다음과 같이 타입을 명시해야 한다.

```
let a: [string, string] = ['malcolm', 'gladwell']
```

- 객체 타입에 프로퍼티 선택형(?)과 마찬가지로 선택형을 지원한다.
- 최소 길이를 갖도록 지정할 때에는 나머지 요소(…)를 사용할 수도 있다. 이런 기능을 잘 활용하면 배열보다 안전성을 높일 수 있기 때문에 권장한다.

**배열과 튜플**

배열과 튜플에 읽기 전용인 readonly를 통해 불변 배열을 만들 수 있다.
읽기 전용 배열은 .push 처럼 내용을 바꾸는 동작 대신 .concat으로 내용을 바꾸지 않는 메서드를 사용해야 한다.
이는 readonly, ReadonlyArray, Readonly 등 선언 방법이 있다.
이런 것들은 스프레드나 .slice 등으로 배열을 조금만 바꿔도 원래 배열을 복사해야하므로 주의하지 않으면 성능이 느려질 수 있다.

### null, undefined, void, never

- null은 값이 없다는 의미이고, undefined는 아직 정의하지 않았음을 의미한다.
- void 는 console.log와 같이 명시적으로 아무것도 반환하지 않는 함수의 반환 타입을 가리킨다.
- never 타입은 절대 반환하지 않는(예외를 던지거나 영원히 실행되는,,, 무한루프와 같은) 함수 타입을 가리킨다. 이는 모든 타입에 할당할 수 있는 특징이 있다.

### enum(열거형)

- 해당 타입으로 사용할 수 있는 값을 열거하는 기법이다. 키를 값에 할당하는, 순서가 없는 자료구조이다.
- 열거형에 문자열 값을 사용하거나 문자열과 숫자 값을 혼합할 수 있다.
- 모든 숫자를 열거형에 할당할 수 있다. → 문자열을 값을 갖는 열거형을 사용해 해결 가능.
  - 다만, 숫자 값을 받는 열거형은 안전성을 해칠 수 있다.
