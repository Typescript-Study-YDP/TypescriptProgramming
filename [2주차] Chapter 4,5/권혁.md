# 내용 정리

## 4장 함수

### 함수 선언과 호출

- 보통 함수의 매개변수의 타입은 명시적으로 정의한다. 타입스크립트는 함수의 매개변수 타입을 추론하지 않기 때문이다.
  - 실무에서 함수의 반환타입은 추론하도록 하는 게 보통이다.
- 함수 생성자는 매개변수 타입과 반환 타입을 지정하지 않으므로 어떤 인수를 건네서도 호출할 수 있기 때문에 사용하지 않는 것이 좋다.

```
// 함수 생성자
let foo = new Function('name', 'return "hello " + name')
```

- 함수의 매개변수를 선언할 때에도 선택형(?)을 통해 선언해 줄 수 있다. 또한 Default Parameter 를 통해 매개변수를 기본값으로 설정할 수 있다. 그러면 인자를 넘겨주지 않아도 되므로 선택적으로 만드는 것과 같다.
- 인수를 여러 개 받는 함수라면 rest Parameter를 통해 배열 형태로 받을 수 있다. arguments는 순수 배열이 아니기 때문에 배열로 변환 후에 배열 내장함수를 사용한다 하더라도 안전하지 않는 방식이다.
  - rest Parameter는 함수의 매개변수 목록 맨 마지막에 위치해야 한다.
- 함수에서 this를 사용하고 싶을 때에는 this 타입을 함수의 첫 번째 매개변수로 선언해준다. 그럼 함수가 어디서 호출하느냐에 따라 this 바인딩이 달라지는 문제를 해결해 줄 수 있다.
- 제너레이터는 함수 앞에 별표(\*)를 통해 명시하고 이것을 호출하면 이터러블 반복자가 반환된다. yield라는 키워드로 값을 방출하고 타입스크립트는 방출된 값의 타입을 이용해 반복자의 타입을 추론할 수 있다.
- 함수에 함수를 인수로 전달하거나 함수에서 다른 함수를 반환하는 경우 호출 시그니처(타입 시그니처)를 통해 타입을 지정할 수 있다.

```
// 호출 시그니처
(a: number, b: number) => number
```

- 함수 시그니처는 바디를 포함하지 않아 타입을 추론할 수 없으므로 타입을 명시해야 하고, 기본값을 지정할 수 없기 때문에 타입을 지정해줘야한다.

```
// 호출 시그니처를 함수 표현식과 합친 예
type Log = (message: string, userId?: string) => void

let log: Log = (message, userId = 'Not signed in') => {
    let time = new Date().toLocaleString()
    console.log(time, message, userId)
}
```

- 위와 같이 매개변수의 타입을 명시하지 않아도 타입스크립트가 message의 타입을 추론한 것을 문맥적 타입화 라고 한다.
- 오버로드된 함수란, 호출 시그니처가 여러 개인 함수를 뜻한다. 만약 하나의 함수에 여러 개의 오버로드 시그니처를 선언하면, 호출자 관점에서 해당 함수의 타입은 이들 오버로드 시그니처들의 유니온이 된다. 즉, 함수를 구현할 때 직접 시그니처를 선언해야 한다.

### 다형성

- 구체 타입이란 boolean, string, Date[] 과 같이 기대하는 타입을 정확하게 알고 있고, 실제 이 타입이 전달되었는지 확인할 때 유용하다. 다만, 미리 타입을 알 수 없을 때에는 제네릭을 사용하면 된다. 제네릭이란 여러 장소에 타입 수준의 제한을 적용할 때 사용하는 플레이스홀더 타입이다. 꺾쇠괄호(<>)를 통해 제네릭임을 선언한다. 그리고 이에 따라 지정된 영역에 속하는 모든 제네릭 타입 매개변수 인스턴스가 한 개의 구체 타입으로 한정되도록 보장한다.
- 제네릭 타입의 선언 위치에 따라 타입의 범위뿐 아니라 타입스크립트가 제네릭 타입을 언제 구체 타입으로 한정하는지도 결정된다. 만약 시그니처의 일부로 제네릭을 사용한다면 타입스크립트는 함수를 실제 호출할 때 구체 타입을 한정한다.
- 추론된 각 제네릭 타입을 명시적으로 한정한 제네릭에 할당할 수 있는지 확인하고 할 수 없다면 에러가 발생한다. 또한 타입스크립트는 인수가 아무것도 없으면 T를 {}로 간주하고 추론한다.
- 여러 제한을 적용하기 위한 다형성은 인터섹션(&)을 통해 구현할 수 있다.
- 제네릭에도 기본 타입을 설정해 줄 수 있다.

```
type MtEvent<T = HTMLElement> = {
    target: T
    type: string
}
```

## 5장 클래스와 인터페이스

### 클래스와 상속

- private 한정자는 자동으로 매개변수를 this에 할당하며 가시성은 private으로 설정한다. protected 한정자는 this에 할당하지만 private과 달리 인스턴스와 서브클래스 인스턴스 모두에 접근을 허용한다. 이처럼 접근 한정자를 이용해 내부 구현 정보를 너무 많이 공개하지 않고 잘 정의된 API만 노출하도록 클래스를 설계할 수 있다.
- abstact 키워드를 통해 해당 클래스에서 인스턴스를 직젖ㅂ 생성하지 못하게 막고 해당 클래스를 상복받은 클래스에서 인스턴스를 허용할 수 있도록 할 수 있다. 이러한 추상 클래스를 구현할 떄는 추상 메서드도 반드시 구현해야 한다.
- 자바스크립트처럼 타입스크립트도 super 호출을 지원한다.
- this를 통해 타입을 지정해 줄 수가 있다. 특히, 자식 클래스가 부모 클래스를 상속받아 사용할 때 반환되는 값 등을 this로 지정해서 각각 인스턴스를 가리킬 수 있게 할 수도 있다.
- 타입 별칭과 인터페이스는 거의 같다고 볼 수 있다. 다만 다른 정의된 내용을 상속 받을 떄에는 타입 별칭은 인터섹션, 인터페이스는 extend 를 사용해준다.
  - 그 외에 타입 별칭은 타입 표현식(&, | 등)을 사용할 수 있다.
  - 인터페이스를 상속할 때 상위 인터페이스를 할당 할 수 있는지 타입스크립트가 확인한다.
  - 이름과 범위가 같은 인터페이스가 여러 개 있다면 이들이 자동으로 합쳐진다.(선언 합침)
- 클래스를 선언할 때 implements 키워드를 통해 인터페이스를 만족시킴을 표현할 수 있다.
- 인터페이스로 인스턴스 프로퍼티를 정의할 순 있지만 가시성 한정자과 static 키워드도 사용할 수 없다. (readOnly는 됨)
- 클래스는 구조 기반 타입을 지원한다. 이름 기반 타입이 아닌.
- 클래스는 값과 타입을 모두 선언한다.
- 클래스에서도 제네릭 타입을 설정해 줄 수 있다.
- 팩토리 패턴은 어떤 객체를 만들지를 전적으로 팩토리에 위임하는 것이다.
- 빌더 패턴은 객체의 생성과 객체 구현 방식을 분리할 수 있다.

---

Q. 타입스크립트는 함수 타입 시그니처에서 반환 타입이 아닌 매개 변수 타입만 추론한다.(O/X)

Q. this 는 어디서 선언되었는지가 아니라 어디서 호출되었느냐에 따라 다르게 바인딩 된다. 함수에서 이를 보장하기 위해서 어떻게 할 수 있을까?

Q. 제네릭이란?

Q. 제네릭에서는 기본 타입을 설정해 줄 수 있다.(O/X)

Q. 타입 별칭과 인터페이스의 차이점은?

Q. 그럼 타입 별칭과 인터페이스 각각 어떨 때 사용하면 좋을까?

Q. 클래스의 constructor에는 제네릭 타입을 선언할 수 없다 (O/X)

Q. 클래스로 한정된 제네릭 타입은 클래스 내부의 어디에서나 사용할 수 있다. (O/X)

Q. final 클래스는 클래스나 메서드를 확장하거나 오버라이드를 할 수 없게 만드는 기능이다. 타입스크립트에서는 이를 지원하지 않지만 어떻게 구현할 수 있을까?
