# 4. 함수

### 함수를 선언하고 호출하는 4가지 방법

```ts
// [1] 이름을 붙인 함수
function exam1() {}

// [2] 함수 표현식
const exam2 = function () {};

// [3] 화살표 함수
const exam3 = () => {};

// [4] 함수 생성자
const exam4 = new Function();
```

### 4번째 방법을 지양해야하는 이유는 무엇일까?

- 매개변수와 반환값의 타입을 지정해주지 못하므로, 어떤한 인수도 가능하기에 타입스크립트가 도와줄 수 있는 방법이 없다.

## 매개 변수

### 선택적 매개 변수와 기본 매개변수

```ts
// 함수에서 선택적 매개 변수는 항상 뒤에 와야한다.
// 기본 매개변수를 설정해줌으로서 선택적으로 활용할 수 있다.
function log(msg: string, userId = 'Not signed In') {
  console.log(msg, userId);
}

// 아래와 선택형 마크(물음표?)와 함께 선택적으로 매개변수를 받을 수 있다.
type Context = {
  appId?: string;
  userId: string;
};
```

### 나머지 매개변수는 어떻게 받을 수 있을까?

```js
// javascript
function sum() {
  return Array.from(arguments).reduce((acc, cur) => acc + cur, 0);
}
sum(1, 2, 3); // 6
```

```ts
// typescript

// spread 연산자를 사용한다.
function sum(...numbers: number[]) {
  return numbers.reduce((acc, cur) => acc + cur, 0);
}
sum(1, 2, 3); // 6
```

## ()외의 함수 호출방법 3가지

- call
- apply
- bind

> call과 apply의 차이는 무엇일까?
>
> - call은 두번째 인수를 펼치지않고 순서대로 인수를 전달하는 반면,
> - apply는 두번째 매개 변수를 펼쳐 함수에 전달한다.

```js
// 코드로 확인해보자!

function add(a, b) {
  return a + b;
}
add(a, d);
add.apply(null, [1, 2, 3]);
add.call(null, 1, 2, 3);
// bind는 함수를 호출하지않고 반환하기에 마지막에 호출을 해주어야한다.
add.bind(null, 1, 2, 3)();
```

**call, apply, bind를 안전하게** 사용해주기 위해선 **strictBindCallApply** 설정값을 활성화해야한다.  
=> false를 하게되면 어떤 일이 일어날까?

## this

```ts
function lessFancyDate() {
  return this.getDate();
}

// 여기서의 this는 예약어이다.
// 다른 매개변수와 완전히 다른 방식으로 처리한다.
function fancyDate(this: Date) {
  return this.getDate();
}

lessFancyDate(); // 런타임 에러 발생
fancyDate(); // 컴파일 에러 발생
```

## 제너레이터와 반복자

- 제너레이터 함수는 여러 개의 값을 생성
- function* 처럼 function뒤에 (*)을 붙여줌으로서 제너레이터를 선언
- 이터러블 반복자가 반환되고, yield로 원하는 값을 반환
- 영구적으로 값을 생산

> downleverIteration을 사용하여 커스텀 반복자를 비활성화하는 것이 번들 사이즈를 줄이는데 좋다.

## 호출 시그니처

```ts
// 이와 함수 타입 표현 방법을 호출 시그니처, 타입 시그니처라고 한다!
type A = (a: number, b: number) => number;
```

- 호출 시그니처는 값이 아닌 타입 정보만 포함한다.
- 다른 타입 정의와 마찬가지로 기본값은 표현할 수 없다.
- 바디를 포함할 수 없으므로 반환 타입을 꼭 명시해야한다.
- ex) 아무것도 리턴하지 않아도 () => void

```ts
// 예제
type Log = (msg: string, userId?: string) => void;

let log: Log = (msg, userId = '여기서 기본값 정의 가능') => {
  console.log(msg, userId);
};

// 문맥적 타입화
// 위에서 msg는 Log로 타입추론이 가능했기에, 매개변수 타입을 명시❌
function times(f: (index: number) => void, n: number) {
  console.log(n);
}

// ⭕️
times((n) => console.log(n), 2);
// ❌
function f(n) {
  // 여기서 n의 타입이 암묵적으로 any가 된다.
  // number로 추론이 불가하다
  console.log(n);
}
times(f, 4);

// 그러므로 인라인으로 호출하도록 한다!
```
