# 내용 정리

## 4장. 함수

### 4.1 함수 선언과 호출

- 자바스크립트에서 함수는 일급객체(first-class object)다.(55)
  - 1. 객체를 다루듯이 함수를변수에 할당하거나
  - 2. 함수를 다른 함수로 전달하거나
  - 3. 함수에서 함수를 반환하거나
  - 4. 객체와 프로토타입에 할당하거나
  - 5. 함수에 프로퍼티를 기록하거나
  - 6. 함수에 기록된 프로퍼티를 읽거나
- 실무에서는 타입스크립트가 반환 타입을 추론하도록 하는 게 보통. 타입스크립트가 해줄 수 있는 일을 개발자가 직접할 필요가 없기 때문.(56)
- 타입스크립트는 함수 생성자를 제외한 모든 문법을 안전하게 지원한다.(57)
  - 안전하지 않으므로 벌떼에 쫓기는 상황이 아니라면 사용하지 않는 편이 좋다.
  - 함수 생성자는 왜 안전하지 않을까?
    - Function은 이름 뒤에 ()를 붙여서 호출할 수 있는 객체로 `Function.prototype`의 모든 프로토타입 메서드를 포함한다.
      하지만 매개타입 변수와 반환타입을 지정하지 않았으므로 어떤 인수를 건네서도 호출할 수 있으며, 이 과정에서 어떤 문제가 발생하더라도 타입스크립트가 도와줄 수 있는 일이 없다.

#### 4.1.1 선택적 매개변수와 기본 매개변수

- `?`를 이용해 선택적 매개변수를 지정할 수 있다.(58)

  ```typescript
  function log(message: string, userId?: string) {
    let time = new Date().toLocaleTimeString();
    console.log(time, message, userId || 'Not signed in');
  }
  ```

- 자바스크립트에서처럼 매개변수에 기본값을 지정할 수 있다.

  - 의미상으로는 호출자가 해당 매개변수에 값을 전달하지 않아도 되므로 매개변수를 선택적으로 만드는 것과 같다.
  - 선택적 매개변수는 뒤에 와야 하지만, 기본 매개변수는 어디에나 추가할 수 있다는 점이 다르다.

  ```typescript
  function log(message: string, userId = 'Not signed in') {
    let time = new Date().toISOString();
    console.log(time, message, userId);
  }
  ```

- 보통 실무에서는 선택적 매개변수보다 기본 매개변수를 더 자주 사용하게 된다.(59)

#### 4.1.2 나머지 매개변수

- `arguments`는 하나도 안전하지 않다는 단점이 있다.(59)
- 나머지 매개변수(...)를 사용해서 안전성까지 챙기도록 하자(60)

  - 함수는 최대 한 개의 나머지 매개변수를 가질 수 있으며 나머지 매개변수는 함수의 매개변수 목록 맨 마지막에 위치해야 한다.

  ```typescript
  // before
  function sumVariadicSafe(): number {
    return Array.from(arguments).reduce((total, n) => total + n, 0);
  }
  // after
  function sumVariadicSafe(...numbers: number[]): number {
    return numbers.reduce((total, n) => total + n, 0);
  }
  ```

#### 4.1.4 this의 타입

- 자바스크립트 this의 동작은 함수를 어떻게 호출하느냐에 영향을 받는다.
- 여러분의 함수에서 this를 사용할 때는 항상 기대하는 this 타입을 함수의 첫 번째 매개변수로 선언하자.
- 그러면 함수 안에 등장하는 모든 this가 의도한 this가 됨을 타입스크립트가 보장한다.

  ```typescript
  function fancyDate(this: Date) {
    return `${this.getDate()}`;
  }

  fancyDate.call(new Date());
  ```

#### 4.1.5 제너레이터 함수

- 제너레이터 함수를 이용하면 값을 생산하는 속도도 정교하게 조절할 수 있다.

#### 4.1.7 호출 시그니처

- 아래 코드는 타입스크립트의 함수 타입 문법으로, 호출 시그니처(call signature) 또는 타입 시그니처(type signature)라 부른다.

  ```typescript
  (a: number, b: number) => number;
  ```

- 타입 수준 코드는 타입과 타입 연산자를 포함하는 코드를 의미한다.
  - 유효한 자바스크립트 코드는 아니지만 유효한 타입스크립트 코드라면 타입 수준.
- 값 수준의 코드는 그 밖의 모든 것을 가리킨다.
  - 어떤 코드가 유효한 자바스크립트 코드라면 값 수준.
- 함수의 호출 시그니처는 구현코드와 거의 같다.

  ```typescript
  // greet(name: string) 함수
  type Greet = (name: string) => string;

  // log(message: string, userId?: string) 함수
  type Log = (message: string, userId?: string) => void;

  // sumVariadicSafe(...numbers: number[]): number 함수
  type SumVariadicSafe = (...numbers: number[]) => number;
  ```

#### 4.1.8 문맥적 타입화

- 이미 log의 타입을 Log로 지정했으므로 타입스크립트가 message의 타입을 string으로 추론할 수 있기 때문이다.
- 문맥적 타입화(contextual typing)라는 타입스크립트 강력한 타입 추론 기능이다.

#### 4.1.9 오버로드된 함수 타입

- 타입스크립트는 이런 동적 특징을 오버로드된 함수 선언으로 제공하고 있다.

### 4.2 다형성

- 제네릭 타입 매개변수
  - 여러 장소에 타입 수준의 제한을 적용할 때 사용하는 플레이스홀더 타입(placeholder type).
  - T는 자리를 맡아둔다는 의미의 '플레이스홀더' 타입
- 꺽쇠괄호(<>)로 제네릭 타입 매개변수임을 선언한다.
  - 꺽쇠괄호를 제네릭 타입 전용의 type 키워드로 보면 된다.
- 제네릭은 함수의 기능을 (구체 타입을 사용할 때보다) 더 일반화하여 설명할 수 있는 강력한 도구다.
- 보통 타입스크립트는 제네릭 타입을 사용하는 순간에 제네릭과 구체 타입을 한정한다.
- '제네릭을 사용할 때'란 구체적으로 무슨 뜻일까?
  - 함수에서는 함수를 호출할 때를 의미하고 클래스라면 클래스를 인스턴스화할 때, 타입 별칭과 인터페이스에서는 이들을 사용하거나 구현할 때를 가리킨다.

#### 4.2.3 제네릭 타입 추론

- 제네릭의 타입을 명시할 때는 모든 필요한 제네릭 타입을 명시하거나 반대로 아무것도 명시해서는 안 된다.

### 4.3 타입 주도 개발

- 타입 시그니처를 먼저 정하고 값을 나중에 채우는 프로그래밍 방식

## 4장에서의 질문

1. 제네릭에 대해서 아는 만큼 설명해주세요.
2. 제너레이터 함수는 어떻게 활용할 수 있나요?
3. 타입스크립트에서 arguments의 사용을 지양해야 하는 이유는 무엇인가요?
4. 안전을 보장하기 위해서 arguments 대신 사용할 수 있는 문법은?
5. 함수의 오버로드 기능으로 얻을 수 있는 이점은?
6. 타입 주도 개발을 통해 얻을 수 있는 이점은?
7. 자바스크립트에서의 함수는 일급 객체입니다. 여기서 일급 객체는 어떤 것인지 설명해주세요.

## 5장. 클래스와 인터페이스

### 5.4 인터페이스

- 클래스는 인터페이스를 통해 사용할 때가 많다.
- 타입 별칭처럼 인터페이스도 타입에 이름을 지어주는 수단이므로 인터페이스를 사용하면 타입을 더 깔끔하게 정의할 수 있다.
- 공통점

  - 타입 별칭을 사용한 모든 곳에 인터페이스로 대신 사용할 수 있다.
  - 둘 다 형태(shape)를 정의하며 두 형태 정의는 서로 할당할 수 있다.

    ```typescript
    // 타입 별칭
    type Sushi = {
      calories: number;
      salty: boolean;
      tasty: boolean;
    };

    // 인터페이스
    interface Sushi {
      calories: number;
      salty: boolean;
      tasty: boolean;
    }
    ```

  - 타입의 조합

    ```typescript
    // 타입 별칭의 조합
    type Food = {
      calories: number;
      tasty: boolean;
    };

    type Sushi = Food & {
      salty: boolean;
    };

    type Cake = Food & {
      sweet: boolean;
    };

    // 인터페이스의 조합
    interface Food {
      calories: number;
      tasty: boolean;
    }

    interface Sushi extends Food {
      salty: boolean;
    }

    interface Cake extends Food {
      sweet: boolean;
    }
    ```

- 차이점(미묘하지만 세 가지 면에서 차이가 난다.)

  - 1. 타입 별칭은 더 일반적이어서 타입 별칭의 오른편에는 타입 표현식(타입 그리고 &, | 등의 타입 연산자)을 포함한 모든 타입이 등장할 수 있다.
       반면 인터페이스의 오른편에는 반드시 형태가 나와야 한다. 예를 들어 아래와 같은 타입 별칭 코드는 인터페이스로 다시 작성할 수 없다.

    ```typescript
    type A = number;
    type B = A | string;
    ```

  - 2. 인터페이스를 상속할 때 타입스크립트는 상속받는 인터페이스의 타입에 상위 인터페이스를 할당할 수 있는지를 확인한다.

  ```typescript
  interface A {
    good(x: number): string;
    bad(x: number): string;
  }

  interface B extends A {
    good(x: string | number): string;
    bad(x: string): string; // 에러: number 타입은 string 타입에 할당할 수 없음(올바른 상속 불가)
  }
  ```

  - 3. 이름과 범위가 같은 인터페이스가 여러 개 있다면 자동으로 합쳐진다.
    - 이때 같은 조건에서 타입 별칭이 여러 개라면 컴파일 타입 에러가 난다.

### 5.5 클래스는 구조 기반 타입을 지원한다

### 5.6 클래스는 값과 타입을 모두 선언한다

### 5.7 다형성

### 5.8 믹스인

### 5.9 데코레이터

### 5.10 디자인 패턴

### 5.11 마치며

## 5장에서의 질문

1. 타입 별칭과 인터페이스의 공통점을 설명해주세요.
2. 타입 별칭과 인터페이스의 차이점을 설명해주세요.
3. 자바스크립트에서 클래스는 언제 사용하면 좋을까요?
