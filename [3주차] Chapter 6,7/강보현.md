# 내용 정리

## 6장. 고급 타입

- 타입스크립트의 타입 시스템은 표현력이 좋을 뿐 아니라 쉽게 사용할 수 있고 타입 제한과 관계 선언을 쉽고 간결하게 만들어주며, 심지어 타입을 명시하지 않아도 대부분 자동으로 추론해준다.(137)

### 6.1 타입간의 관계

- 서브타입은 두 개의 타입 A와 B가 있고, B가 A의 서브타입이면 A가 필요한 곳에는 어디든 B를 안전하게 사용할 수 있다.(138)
  - `A <: B`는 'A는 B와 같거나 B의 서브타입'이라는 의미다.(140)
- 슈퍼타입은 두 개의 타입 A와 B가 있고, B가 A의 슈퍼타입이면 B가 필요한 곳에는 어디든 A를 안전하게 사용할 수 있다.(139)
  - `A >: B`는 'A는 B와 같거나 B의 슈퍼타입'이라는 의미다.(140)
- 어떤 객체를 슈퍼타입을 기대하는 곳에 사용한다는 것은 분명 안전하지 않을 수 있다. 그런데 왜 타입스크립트는 이를 허용할까?
  - 전반적으로 타입스크립트는 완벽한 안전성을 추구하도록 설계되지는 않았다. 완벽함보다는 실제 실수를 잡는 것과 쉬운 사용(프로그래밍 언어 이론 학위를 받지 않더라도 에러가 발생한 이유를 알도록)이라는 두 가지 목표를 균형 있게 달성하는 것이 타입스크립트 타입 시스템의 목표다.(141)
- 타입스크립트는 다음과 같이 동작한다.(142)
  - 어떤 형태를 요구할 때 건넬 수 있는 타입은, 요구되는 타입에 포함된 프로퍼티 각각에 대해 '<: 기대하는 타입'인 프로퍼티를 가지고 있어야 한다.
  - 기대하는 프로퍼티 타입의 슈퍼타입인 프로퍼티가 있다면 건넬 수 없다.
  - 타입과 관련해 타입스크립트 형태(객체와 클래스)는 그들의 프로퍼티 타입에 공변(covariant)한다고 말한다.
  - 즉, 객체 B에 할당할 수 있는 객체 A가 있다면 '객체 A의 각 프로퍼티 <: B의 대응 프로퍼티'라는 조건을 만족해야 한다.
- 가변성의 네 종류(142~143)
  1. 불변(invariance): 정확히 T를 원함.
  2. 공변(covariance): <:T를 원함(= T와 같거나 T의 서브타입).
  3. 반변(contravariance): >:T를 원함(= T와 같거나 T의 슈퍼타입).
  4. 양변(bivariance): <:T 또는 >:T를 원함(= 공변 + 양변)
- **타입스크립트에서 모든 복합 타입의 멤버(객체, 클래스, 배열, 함수, 반환 타입)은 공변이며 함수 매개타입만 예외적으로 반변이다.**(143)
- 함수의 반환 타입은 공변, 즉 함수가 다른 함수의 서브타입이라면 '서브타입 함수의 반환 타입 <: 다른 함수의 반환타입'을 만족해야 한다.(146)
- 할당성이란 A라는 타입을 다른 B라는 타입이 필요한 곳에 사용할 수 있는지를 결정하는 타입스크립트 규칙을 말한다.(147)
- 타입 넓히기(type widening)은 타입스크립트의 타입 추론이 어떻게 동작하는지 이해하는 데 필요한 핵심 개념이다.(148)
- `let`이나 `var`로 선언했고 타입이 넓혀지지 않은 변수에 값을 다시 할당하면 타입스크립트는 새로운 값에 맞게 변수의 타입을 넓힌다. 하지만 변수를 선언할 때 명시적으로 타입 어노테이션을 추가하면 이러한 자동확장이 일어나지 않는다.(149)

  ```typescript
  const a = 'x'; // 'x'
  let b = a; // string

  const c: 'x' = 'x'; // 'x'
  let d = c; // 'x'
  ```

- `null`이나 `undefined`로 초기화된 변수는 `any` 타입으로 넓혀진다.(149)

  ```typescript
  let a = null; // any
  a = 3; // any
  a = 'b'; // any
  ```

- 타입스크립트는 타입이 넓혀지지 않도록 해주는 `const`라는 특별 타입을 제공한다. 이를 통해 타입 어서션을 활용하자.(149)
- `const`를 사용하면 타입 넓히기가 중지되며 멤버들까지 자동으로 `readonly`가 된다(중첩된 자료구조에도 재귀적으로 적용한다).(150)
- 타입스크립트가 변수를 가능한 좁은 타입으로 추론하길 원한다면 `as const`를 이용하자.(150)
- 타입스크립트가 신선한(fresh) 객체 리터럴 타입 T를 다른 타입 U에 할당하려는 상황에서 T가 U에는 존재하지 않는 프로퍼티를 가지고 있다면 타입스크립트는 이를 에러로 처리한다.(151)
  - 여기서 '신선한 객체 리터럴 타입'이란 타입스크립트가 객체 리터럴로부터 추론한 타입을 가리킨다.
  - 이 에러는 초과 프로퍼티 확인(excess property checking) 기능 덕분에 검출할 수 있다.
- 유니온 타입의 다양한 경우를 처리하는 함수를 구현해야 한다면 태그된 유니온을 사용하자.(158)
  - 예를 들어 플러스 액션(Flux action), 리덕스 리듀서(Redux reducer), 리액트(React)의 `useReducer`에서는 태그된 유니온이 아주 중요하다.

### 6.2 종합성

- 타입스크립트는 다양한 상황의 모든 가능성을 확인하며, 빠진 상황이 있다면 이를 경고한다.(159)

### 6.3 고급 객체 타입

- 응답 타입에 키인(key in)하는 방법이 있다.(162)
- 모든 형태(객체, 클래스 생성자, 클래스 인스턴스)와 배열에 키인할 수 있다.(163)

  ```typescript
  type APIResponse = {
    user: {
      friendList: {
        friends: {
          firstName: string;
          lastName: string;
        }[];
      };
    };
  };

  type FriendList = APIResponse['user']['friendList'];

  // 친구 한 명의 타입도 얻을 수 있다.
  type Friend = FriendList['friends'][number];
  ```

- 일반 자바스크립트 객체의 필드를 찾는 문법과 키인 문법은 의도적으로 비슷하게 만들어졌다.(163)
  - 즉, 객체에서 값을 찾는 것처럼 형태에서 타입을 찾을 수 있다.
  - 다만 키인으로 프로퍼티 타입을 찾을 때 점(.)이 아니라 대괄호 표기법)([])을 사용한다는 점만 주의하자.
- `keyof` 연산자를 이용하면 객체의 모든 키를 문자열 리터럴 타입 유니온으로 얻을 수 있다.(163)
- `Record`를 이용하면 키와 값에 제한을 추가할 수 있다.(166)

  ```typescript
  // 한 주의 각 요일을 다음 요일로 매핑하도록 만들어보자.
  type Weekday = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri';
  type Day = WeekDay | 'Sat' | 'Sun';

  let nextDay: Record<Weekday, Day> = {
    Mon: 'Tue', // 에러: { Mon: 'Tue' } 타입에는 'Record<Weekday, Day> 타입 중 Tue, Wed, Thu, Fri가 빠져있음
  };
  ```

- `Record`는 일반 객체의 인덱스 시그니처에 비해 자유롭다.(167)
  - 일반 인덱스 시그니처에서는 객체 값의 타입은 제한할 수 있지만, 키는 반드시 일반 string, number, symbol이어야 한다.
  - 하지만 `Record`에서는 객체의 키 타입도 string과 number의 서브타입으로 제한할 수 있다.
- 매핑된 타입(mapped type)을 이용해 `Record`보다 더 안전하게 타입을 선언할 수 있다.

  ```typescript
  let nextDay: { [K in Weekday]: Day } = {
    Mon: 'Tue', // 에러: { Mon: 'Tue' } 타입에는 '{ Mon: Weekday; Tue: Weekday; Wed: Weekday; Thu: Weekday; Fri: Weekday } 타입이 정의한 프로퍼티 중 Tue, Wed, Thu, Fri를 포함하지 않음
  };
  ```

- 매핑된 타입은 타입스크립트만의 고유한 언어 기능이다. 리터럴 타입처럼 매핑된 타입도 자바스크립트에 정적 타입을 덧씌울 수 있게 해주는 유틸리티 기능이다.(167)
  - 인덱스 시그니처와 마찬가지로 한 객체당 최대 한 개의 매핑된 타입을 가질 수 있다.
- 이름에서 알 수 있듯이 매핑된 타입은 객체의 키와 값 타입을 매핑하는 수단을 제공한다.(167)
- 매핑된 타입은 `Record`보다 강력하다. 객체의 키와 값에 타입을 제공할 뿐 아니라, 키인 타입과 조합하면 이름 별로 매핑할 수 있는 값 타입을 제한할 수 있기 때문이다.(168)

### 6.4 고급 함수 타입들

- 타입스크립트는 튜플을 선언할 때 튜플의 타입에 관대한 편이다.(171)
- 타입 어서션을 사용하지 않고 추론 범위도 좁히지도 않고, 그리고 읽기 전용 한정자를 추가하는 `as const`도 사용하지 않으면서 튜플을 튜플 타입으로 만들려면 어떻게 해야 할까?(171)
  - 타입스크립트가 나머지 매개변수의 타입을 추론하는 기법을 이용하면 된다.
  - 튜플 타입이 많이 등장하는 코드라면 이 기법을 활용해 타입 어서션 사용을 줄일 수 있다.(172)
- 타입 안전 장치는 타입스크립트의 내장 기능으로 `typeof`와 `instanceof`로 타입을 정제할 수 있게 해준다.(173)

  - 하지만 때로는 자신만의 타입 안전 장치가 필요한데 이때는 `is` 연산자를 사용한다.

  ```typescript
  function isString(a: unknown): a is string {
    return typeof === 'string';
  }
  ```

## 7장. 에러 처리

- 에러를 표현하고 처리하는 패턴 네 가지(194)
  1. null 반환
  2. 예외 던지기
  3. 예외 반환
  4. Option 타입

### 7.4 null 반환

- 어떤 특정 값을 반환하는 대신 값을 포함하거나 포함하지 않을 수도 있는 컨테이너를 반환한다는 것이 `Option` 타입의 핵심이다.(201)
- 성공하거나 실패할 수 있는 연산을 연달아 수행할 때 `Option`을 유용하게 사용할 수 있다.(208)
  - `Option`을 사용하면 타입 안전성을 제공할 뿐만 아니라 타입 시스템을 통해 해당 연산이 실패할 수 있음을 사용자에게 알려줄 수 있다.
- 하지만 `Option`에도 단점이 있다.(208)
  - 이 기능은 `None`으로 실패를 표현하기 때문에 무엇이 왜 실패했는지는 자세히 알려주지 못한다.
  - 또한 `Option`을 사용하지 않는 다른 코드와는 호환되지 않는다는 것도 단점이다.
  - 호환되지 않는 API는 `Option`을 반환하도록 직접 감싸야 한다.

## 3주차 스터디 후 회고

- 3주차는 급작스러운 사정으로 불참하였다..ㅠ 중요한 내용이었어서 참석 못한 게 넘넘 아쉽다..!
- **💡 팀원의 정리 내용을 보면서 알게 된 것**

  1. 읽어봐야 할 아티클(1)
     [공변성과 반공변성](https://www.zerocho.com/category/TypeScript/post/5faa8c657753bd00048a27d8)

  2. 읽어봐야 할 아티클(2)
     [null 리턴은 왜 나쁠까?](https://toss.tech/article/engineering-note-2)
