# 6. 고급 타입


# 7. 에러 처리
타입스크립트는 런타임에 발생할 수 있는 예외를 <br/>
컴파일 타임에 잡을 수 있도록 최선을 다한다.
    
⇒ 하지만, 런타임 예외는 언젠가 발생하기 마련이다.<br/>
네트워크 장애, 파일시스템 장애, 입력 파싱 에러, 스택 오버플로우, 메모리 부족 에러까지 모두 막을 수는 없다.<br/>

- [타입스크립트에서 에러를 표현하고 처리하는 일반적인 방식 4가지]
- null 반환
- 예외 던지기
- 예외 반환
- Option 타입

## 7.1 null 반환
null을 반환하는 방식 <br />
- 어떤 작업이 실패했음을 단순하게 알릴 때
- 단순히 에러 발생했을 때 처리

```
// 사용자의 생일을 입력받아, 그 입력을 날짜로 파싱하고, 유효한 날짜인지 검증한 뒤 결과를 출력

// 사용자로부터 입력 받기
function ask() {
    return prompt('당신의 생일은 언제입니까?');
}

// 입력된 생일을 Date 객체로 변환하고 유효성 검사하기
function parse(birthday: string): Date | null {
    let date = new Date(birthday);
    if (!isValid(date)) {
        return null;
    }
    return date;
}

// Date 객체가 유효한지 검사하기
function isValid(date: Date) {
    return Object.prototype.toString.call(date) === '[object Date]' && !Number.isNaN(date.getTime());
}

// 날짜를 파싱하고 결과를 처리하기
let date = parse(ask());

if (date) {
    console.info('날짜는', date.toISOString());
} else {
    console.error('Error parsing date for some reason');
}

```

장점<br />
- 타입 안정성을 유지하며 에러를 처리하는 "가장 간단한 방법"

단점<br />
- 문제가 생긴 원인을 알 수 없음 (콘솔로그로 일일이 확인하며 디버깅해야함)
- 조합이 어려워짐(모든 연산에서 null을 확인해야함 => 연산 중첩/ 연결 시 코드가 지저분해짐)


## 7.2 예외 던지기
문제가 발생하면 null 대신,<br /> 
예외를 던지자.<br />
그럼 어떤 문제냐에 따라 대처가 가능할 수 있고,<br />디버깅에 도움되는 메타데이터도 얻을 수 있다.<br />

- 실패한 이유와 관련된 정보가 필요할 때
- 에러 처리 관련 코드를 더 적게 작성하고 싶을 때

### RangeError 예외 던지기
RangeError는 일반적으로 숫자 값이 특정 범위를 벗어났을 때 사용되지만, <br />
아래 예제에서는 날짜 형식이 예상된 범위나 형식에 맞지 않는 경우에 사용하고 있습니다.
```
function parse(birthday: string) : Date {
    let date = new Date(birthday)

    // 입력된 문자열이 Date 객체로 변환되었을 때, 그 날짜가 유효하지 않다는 것을 감지하면 RangeError를 던짐
    if (!isValid(date)){
        throw new RangeError('날짜를 YYYY/MM/DD형식으로 입력하세요')
    }
    return date
}

// ...
try {
    let date = parse(ask())
    console.info('Date is', date.toISOString())
} catch(e){
    if (e instanceof RangeError){
        console.error(e.message)
    } else {
        // RangeError가 아닌 다른 종류의 예외인 경우, 예외를 다시 던짐
        throw e
    }
}

```

### 커스텀 에러 타입 던지기
- 어떤 문제가 생겼는지 알려줄 수 있다.
- 문제가 생긴 이유도 설명할 수 있다.
    
여러 동작을 하나의 `try/catch`구문으로 감싸는 형태
=>연쇄적이고 중첩된 동작을 효율적으로 만들 수 있다.

```
// 커스텀 에러 타입
class InvalidDateFormatError extends RangeError {}
class DateIsInTheFutureError extends RangeError {}

function parse(birthday: string) : Date {
    let date = new Date(birthday)

    if (!isValid(date)){
        throw new InvalidDateFormatError('날짜를 YYYY/MM/DD형식으로 입력하세요')
    }
    if (date.getTime() > Date.now()){
        throw new DateIsInTheFutureError("에러! 입력된 날짜가 현재 시간보다 미래입니다.")
    }
    return date
}

try{
    let date = parse(ask())
    console.info('Date is', date.toISOString())
} catch (e) {
    if (e instanceof InvalidDateFormatError){
        console.error(e.message)
    } else if (e instanceof DateIsInTheFutureError){
        console.info(e.message)
    } else {
        throw e
    }
}
```
어떤 에러가 던져지는지 알고 처리하기 위해, 아래와 같이<br />
주석으로 정보를 추가하는 것이 좋다.
```
/**
    * @throw {InvalidDateFormatError} 사용자가 생일을 잘못 입력함
    * @throw {DateIsInTheFutureError} 사용자가 생일을 미래 날짜로 입력함
*/
```

## 7.3 예외반환
- 실패한 이유와 관련된 정보를 제공할 때
- 가능한 모든 예외를 사용자가 명시적으로 처리하게 하고싶을 때 

타입스크립트는 throws 문을 지원하지 않는다. <br />

→ 하지만, **유니온** 을 통해 비슷하게 흉내낼 수 있다.<br />

```
// `parse` 시그니처에서 발생 가능한 예외 나열
function parse(birthday: string): Date | InvalidDateFormatError | DateIsInTheFutureError {
    let date = new Date(birthday)

    // 사용자에게 어떤 에러가 발생하는지 전달
    if (!isValid(date)){
        return new InvalidDateFormatError('날짜를 YYYY/MM/DD형식으로 입력하세요')
    }
    if (date.getTime() > Date.now()){
        return new DateIsInTheFutureError('생일을 미래 날짜로 입력하셨군요')
    }
    return date
}
```
이 경우 유니온에 해당하는 상황을 처리해야 한다.
(Date | InvalidDateFormatError | DateIsInTheFutureError)
⇒ 그렇지 않으면 컴파일 타입에 TypeError가 발생한다.

```
// 모든 3가지의 상황을 처리해봅시다

let result = parse(ask()) // 날짜 또는 에러

// 사용자는 각각 에러를 모두 처리하거나 다시 던지도록 강제
if (result instanceof InvalidDateFormatError){
    console.error(result.message)
} else if (result instanceof DateIsInTheFutureError){
    console.info(result.message)
} else {
    console.info('Date is', result.toISOString())
}
```
타입 시스템을 활용해 다음을 수행하였다.
> 1. `parse` 시그니처에서 발생 가능한 예외 나열
> 2. 메서드 사용자에게 어떤 에러가 발생하는지 전달
> 3. 메서드 사용자가 각각 에러를 모두 처리하거나 다시 던지도록 강제

## 7.4 Option 타입
특수 목적 데이터 타입을 사용해 예외를 표현하는 방법 <br/>
에러가 발생한 이유는 안알려줌<br/>

어떤 특정 값을 반환하는 대신,
> 값을 포함하거나 포함하지 않을 수도 있는 컨테이너를 반환한다!

- 장: 여러 연산을 연쇄적으로 수행할 수 있게 된다.
- 단: 이런 데이터 타입을 사용하지 않는 다른 코드와는 호환되지 않는다.


```

```
### 배열 구조의 컨테이너
언제든 실패할 수 있는 여러 동작을 연쇄적으로 수행할 때


### Option and Some 사용하기

**Option이란?**
- Some<T>, None 이 구현하게 될 인터페이스
- Option 은 타입이기도 하고, 함수이기도 하다.

타입 관점: Some과 None의 슈퍼타입
함수 관점: Option 타입의 새 값을 만드는 기능
```
interface Option<T> {} // Some<T>, None이 공유하는 인터페이스

class Some<T> implements Option<T> {  //연산에 성공하여 값이 만들어짐.
    constructor(private value: T) {}
}

class None implements Option<never> {} // 연산 실패하여 값이 없음.
```

장점<br />
-
-

단점<br />
-
-