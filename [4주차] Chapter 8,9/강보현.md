# 내용 정리

## 목차

- [8장. 비동기 프로그래밍, 동시성과 병렬성](#8---------------------)
  - [8.1 자바스크립트의 이벤트 루프](#81---------------)
  - [8.2 콜백 사용하기](#82--------)
    - [요약](#--)
  - [8.3 프로미스로 정상 회복하기](#83--------------)
  - [8.4 async와 await](#84-async--await)
  - [8.5 비동기 스트림](#85--------)
  - [8.6 타입 안전 멀티스레딩](#86------------)
- [9장. 프론트엔드 프레임워크와 백엔드 프레임워크](#9------------------------)
  - [9.1 프론트엔드 프레임워크](#91------------)
    - [리액트](#---)
    - [앵귤러](#---)
  - [9.2 타입 안전 API](#92-------api)
  - [9.3 백엔드 프레임워크](#93----------)
  - [9.4 마치며](#94----)

## 8장. 비동기 프로그래밍, 동시성과 병렬성

- 스레드 하나로 비동기 작업을 처리하는 **이벤트 루프**가 바로 자바스크립트 엔진의 표준 모델이다.(211)
- 자바스크립트는 이벤트 루프 기반의 동시성 모델을 이용해 멀티스레드 기반 프로그래밍에서 공통적으로 나타나는 문제점을 해결한다.(211)
  - 문제점: 동기화된 데이터 타입의 오버헤드, 뮤텍스(mutex), 세마포어(semaphore), 기타 멀티스레딩의 골칫거리 등.

### 8.1 자바스크립트의 이벤트 루프

<img src="https://baeharam.netlify.app/media/js/overview.png" width="600" alt="이벤트 루프" />

- 간략한 설명

  - 자바스크립트 엔진, Web API, 태스크 큐로 구성되어 있다.
  - 자바스크립트 엔진은 Heap과 Call Stack으로 나눠져있다.
    - **Heap**은 메모리를 관리하는 곳으로 변수와 객체의 메모리 할당이 이루어진다.
    - **Call Stack**은 코드 실행을 관리하며, 코드가 실행될 때 호출 스택이 Stack의 형태로 쌓인다.
  - 일반적인 작업은 콜스택(Call Stack)에서 이루어집니다.
  - 시간이 소요되는 작업들(setTimeout, 이벤트, HTTP 요청 메서드 등)은 WebAPI에서 대기하다가 콜백 큐(Callback Queue)로 보내집니다.
  - Call Stack이 비워져 있을때만 Callback Queue에 저장되어있던 작업들을 Call Stack으로 보냅니다.

- 자세한 동작원리(213)
  1. 메인 자바스크립트 스레드는 `XMLHTTPRequest`(AJAX 요청), `setTimeout`(잠자기), `readFile`(디스크에서 파일 읽기) 등의 네이티브 비동기 API를 호출한다.
     - 위 API들은 자바스크립트 플랫폼에서 제공하며 직접 만들 수 없다.(다만 브라우저 플랫폼을 포크하거나 C++용 NodeJS를 확장하면 가능)
  2. 네이티브 비동기를 호출한 이후에 다시 메인 스레드로 제어가 반환되며 마지막 실행됐던 지점부터 코드가 다시 실행된다.
  3. 비동기 작업이 완료되면 플랫폼은 태스크를 이벤트 큐에 추가한다.
     각 스레드가 자신만의 큐를 가지고 있으며, 이를 이용해 비동기 연산 결과를 메인 스레드로 전달한다.
     태스크에는 호출 자체와 관련한 메타 정보 일부와 메인 스레드에 연결된 콜백 함수의 참조가 들어 있다.
  4. 메인 스레드의 콜 스택이 비면 플랫폼은 이벤트 큐에 남아 있는 태스크가 있는지 확인한다.
     대기 중인 태스크가 있으면 플랫폼은 그 태스크를 실행한다. 이때 함수 호출이 일어나며 제어는 메인 스레드 함수로 반환된다.
     함수 호출이 끝나고 콜스택이 다시 비면 플랫폼은 다시 기다리는 태스크가 있는지 이벤트 큐에서 확인한다.
     콜 스택과 이벤트 큐가 모두 비고, 모든 비동기 네이티브 API 호출이 완료될 때까지 이 과정을 반복한다.

### 8.2 콜백 사용하기

- 비동기 자바스크립트 프로그램의 기본 단위는 콜백(callback)이다.(214)

  - 콜백은 평범한 함수로, 다른 함수의 인수 형태로 전달된다.

    ```javascript
    const array = [1, 4, 9, 16];

    const map = array.map((x) => x * 2); // [2, 8, 18, 32]
    ```

- 하지만 이런 콜백 방식은 연달아 수행되는 작업을 코드로 표현하기 어려운 문제가 있다.(216)
  ![콜백 지옥 or 콜백 피라미드](https://hanamon.kr/wp-content/uploads/2021/08/%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%A9%E1%86%A8.png)

- 여러 동작을 연달아 실행할 때 보통 한 동작이 성공했을 때만 다음 동작으로 이어가고, 에러가 발생하면 즉시 빠져나와야 할 때가 많다. 콜백을 이용하면 이런 제어를 수동으로 처리해야 한다.(217)
- 비동기 동작 여러 개를 이어 붙이는 것도 유용하지만, 때로는 함수들을 병렬로 실행시킨 후 모두가 완료됐을 때 통지하도록 하거나, 서로 경쟁시켜 가장 먼저 끝난 작업 결과를 이용하는 등의 방식으로 활용할 수도 있다.(217)

#### 요약

1. 간단한 비동기 작업에는 콜백을 사용한다.
2. 다만, 콜백은 비동기 작업이 여러 개로 늘어나면 금방 복잡해진다.

### 8.3 프로미스로 정상 회복하기

- Promise는 **비동기 작업의 완료 또는 실패와 같은 결과를 나타내는 객체**이다.
- 주로 콜백 지옥(callback hell)을 해결하기 위해 사용된다.
- `new Promise(executor)`를 통해 생성되며, 실행자(executor) 함수는 resolve와 reject를 인자로 받는다.
- `then` 및 `catch` 메서드를 사용하여 성공 또는 실패 시 수행할 작업을 정의할 수 있다.

  - 한 작업이 성공하면 다음 작업을 실행하며, 그 중 하나가 실패하면 곧장 catch 절로 직행한다.(218)

  ```javascript
  const myPromise = new Promise((resolve, reject) => {
    // 비동기 작업 수행
    if (작업이 성공적) {
      resolve(결과);
    } else {
      reject(에러);
    }
  });

  myPromise.then((result) => {
    // 성공 시 처리
  }).catch((error) => {
    // 실패 시 처리
  });
  ```

- resolve 매개변수 타입은 우리가 어떤 API를 사용하는지에 따라 달라진다.(220)
  - 아래 예제에서는 result 타입이 매개변수의 타입이 된다.
- reject의 매개변수 타입은 항상 Error 유형이 된다.

  ```typescript
  type Executor<T, E extends Error> = (
    resolve: (result: T) => void,
    reject: (error: E) => void,
  ) => void;
  ```

### 8.4 async와 await

- **`async` 함수는 비동기 작업을 수행하고, 그 결과를 `Promise`로 반환하는 함수**이다.
- `async` 키워드로 함수를 선언하고, 내부에서 `await` 키워드를 사용하여 Promise가 완료될 때까지 기다린다.
- 코드가 동기적으로 보이도록 작성할 수 있어 가독성이 좋아진다.
  → 프로미스의 then, catch, finally와 같은 후속 처리 메서드에 콜백함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기처리처럼 프로미스가 처리 결과를 반환하도록 할 수 있기 때문.
- `finally`는 then과 catch를 실행한 다음 최후로 실행되는 구문이다.(223)

  ```javascript
  // before
  function getUser() {
    getUserID(18)
      .then(user => getLocation(user))
      .then(location => console.info('위치 가져옴!, location))
      .catch(error => console.error(error))
      .finally(()=> console.info('위치 가져오기 완료!));
  }

  // after
  async function getUser() {
    try {
      let user = await getUserID(18);
      let location = await getLocation(user);
      console.info('위치 가져옴!, location);
    } catch (error) {
      console.error(error);
    } finally {
      console.info('위치 가져오기 완료!);
    }
  }
  ```

### 8.5 비동기 스트림

- 만약 미래의 서로 다른 시점에 이용할 수 있게 될 값이 여러 개라면 어떻게 처리해야할까?(224)
  - 예시
    - 파일 시스템에서 파일의 일부를 읽는 상황
    - 넷플릭스 서버로부터 비디오 스트리밍의 픽셀들을 받는 상황
    - 폼을 작성하느라 여러 키를 입력하는 상황
    - 저녁 파티에 여러 명의 친구가 오는 상황
    - 선거 시 부재자 투표가 이루어지는 상황
- 가장 흔히 NodeJS의 EventEmitter 같은 이벤트 방출기(event emitter)를 이용하거나 RxJS 같은 리액티브 프로그래밍 라이브러리를 사용한다.(224)
  - 두 방식의 차이는 콜백과 프로미스의 관계와 비슷하다. 이벤트 방출기는 빠르고 가벼운 반면, 리액티브 프로그래밍 라이브러리는 더 강력하며 이벤트 스트림을 조합하고 연결하는 기능을 제공한다.

### 8.6 타입 안전 멀티스레딩

- 때로는 CPU를 많이 사용하는 작업이 필요해진다.(229)
  - 진정한 병렬성, 즉 작업을 여러 개의 스레드로 분리해서 속도를 높이거나 메인 스레드의 부하를 줄여 반응성을 높여야 할 때가 있다.
- 이럴 때는 브라우저와 서버에서 안전하게 병렬 프로그램을 구현하는 패턴을 사용하여 해결한다.
  1. 브라우저에서 웹 워커 활용하기(229~239)
  2. NodeJS에서 자식 프로세스 이용하기(240~241)

## 9장. 프론트엔드 프레임워크와 백엔드 프레임워크

### 9.1 프론트엔드 프레임워크

- 타입스크립트에서 내장 DOM API를 사용하려면 간단히 프로젝트의 `tsconfig.json`에 필요한 타입 선언을 추가하기만 하면 된다.(244)

  ```json
  {
    "compilerOptions": {
      "lib": ["dom", "es2015"]
    }
  }
  ```

- `lib`라는 옵션은 프로젝트의 코드를 처리할 때 특정 타입을 선언에 포함하도록 타입스크립트에 지시한다.(244)
  - TSC가 코드 실행 환경에서 이용할 수 있다고 가정하는 API를 설정한다.
  - 예를 들어 ES5의 `Function.prototype.bind`, ES2015의 `Object.assign`, DOM의 `document.querySelector` 등.
  - 이 설정은 아무런 코드도 추가하지 않으므로 런타임에 추가되는 자바스크립트 코드도 없다.
- 하지만 실무에서의 프론트엔드 응용 프로그램의 대부분은 DOM 렌더링, 데이터 바인딩, 이벤트 처리 등을 추상화하는 데 프레임워크를 이용한다.(245)

#### 리액트

- 리액트 응용 프로그램의 기본 빌딩 블록인 리액트 컴포넌트는 타입스크립트로 정의되고 소비되므로 안전하다.(245)
- 리액트에서는 자바스크립트 XML(JavaScript XML, JSX)라는 특별한 DSL을 이용해 뷰를 정의하고 자바스크립트 코드에 바로 삽입할 수 있다.
  - DSL이란, Domain Specific language, 도메인 특화언어, 특정 기능이나 영역을 위해 만들어진 언어이다.
- JSX를 이용하면 일반 HTML처럼 보이는 코드를 구현할 수 있다.
  - 이렇게 구현한 코드는 자동으로 자바스크립트 엔진에서 실행할 수 있는 타입으로 컴파일된다는 것이 장점이다.
- 타입스크립트는 다음 세가지 JSX 모드를 지원한다.

  - 이 모드는 출력 단계에만 영향을 미치며 타입 검사에는 영향을 미치지 않습니다.

  1. `react`: `React.createElement`를 출력하고 사용하기 전 JSX 변환을 거칠 필요가 없으며 출력 파일 확장자는 .js이다.
  2. `react-native`: 모든 JSX를 유지한다는 점에서 preserve 모드와 유사하나, 출력 파일 확장자가 .js라는 차이가 있다.
  3. `preserve`: JSX를 출력 일부로 유지하여 이를 다른 변환 단계(예: Babel)에서 추가로 사용한다. 또한 출력 파일 확장자는 .jsx이다.

  <img src="https://github.com/Typescript-Study-YDP/TypescriptProgramming/assets/65386533/4d047887-66bb-4b7a-a8fd-4f7f4d875029" width="800" alt="모드별 입출력 및 확장자 정보" />

  - 설정하는 방법은 아래와 같다.

    ```json
    {
      "compilerOptions": {
        "jsx": "react",
        "jsx": "react-native",
        "jsx": "preserve"
      }
    }
    ```

- 리액트는 DOM 이벤트들을 위한 고유의 래퍼 타입 집합을 제공한다.(250)

  - 리액트 이벤트를 사용할 때 일반 DOM 이벤트 타입 대신 리액트 이벤트 타입을 사용해야 한다.

    ```tsx
    onClick(event: React.MouseEvent<HTMLButtonElement>): void
    ```

- `useState`에 초깃값으로 `true` or `false`와 같은 불린값을 전달하면 타입스크립트는 상태 정보가 `boolean`이라는 사실을 추론할 수 있다.(250)

  ```tsx
  const [toggled, setToggled] = React.useState(false);
  ```

- 만약 타입스크립트가 추론할 수 없는 타입, 배열과 같은 타입을 사용한다면 타입을 명시해야한다.(250)

  ```tsx
  const [list, setList] = React.useState<number[]>([]);
  ```

#### 앵귤러

- 앵귤러는 뷰 렌더링 뿐만 아니라 네트워크 요청 전송/관리 라우팅, 의존성 주입 등의 기능도 제공한다.(253)
- 태생적으로 타입스크립트로 동작하게 만들어졌다.(타입스크립트로 구현된 프레임워크다!)
- 앵귤러 명령행 유틸리티인 앵귤러 CLI의 일부로 제공되는 선행(Ahead-of-Time, AoT) 컴파일러는 앵귤러의 핵심이다.

  - 타입스크립트 어노테이션으로 제공한 타입 정보를 이용해 코드를 일반 자바스크립트로 컴파일한다.
  - 앵귤러는 타입스크립트를 직접 호출하지 않고 전반적인 최적화 및 변형을 가한 다음 이를 궁극적으로 타입스크립트에 위임해 자바스크립트로 컴파일한다.

- 앵귤러는 의존성 주입(Dependency Injection, DI) 기능을 기본으로 제공한다.(255)

  - 의존성 주입은 프레임워크가 서비스를 인스턴스화하고 이 서비스를 필요로 하는 컴포넌트와 서비스에 인수로 제공하는 기능이다.
  - 덕분에 서비스와 서비스와 컴포넌트를 인스턴스화하고 테스트하기가 쉬워진다.

### 9.2 타입 안전 API

- 현재의 클라이언트와 서버는 100% 타입 안전하다.(257)
  - 하지만 언젠가는 HTTP, TCP, 소켓 기반 프로토콜처럼 타입을 사용하지 않는 네트워크 프로토콜로 통신해야 할 수도 있다. 그럴 땐?
- 그럼 어떻게 해야 그런 상황이 발생하게 되더라도 타입 안전성을 유지할 수 있을까?
  1. 타입 안전성을 제공하는 프로토콜을 직접 개발한다.
  2. 타입을 지원하는 코드 생성 API(258)
     - RESTful API용 스웨거(Swagger)
     - GraphQL용 아폴로(Apollo)와 릴레이(Relay)
     - RPC용 gRPC와 아파치 스리프트(Apache Thrift)
     - 위 도구들은 서버와 클라이언트가 동일한 프로토콜을 사용하도록 하여 이를 특정 언어에 맞는 구조로 컴파일한다.
       - 동일한 프로토콜: 스웨거(데이터 모델) 아폴로(GraphQL 스키마), gRPC(ProtocolBuffers)
       - 특정 언어: 우리 예제로는 타입스크립트

### 9.3 백엔드 프레임워크

- 전통적으로는 데이터베이스와 상호작용하는 응용 프로그램을 만들 때 처음에는 타입을 갖지 않는 SQL 또는 API 호출을 그대로 사용해왔다.(259)
- 수동으로 타입을 추가하여 안전한 API로 개선이 가능하지만, SQL API 자체는 여전히 상당히 저수준이므로 순식간에 잘못된 타입을 사용하거나 타입 지정을 깜빡해서 귀결되기 십상이다.(260)
- 때문에 객체 관계 매퍼(object-relational mapper, ORM)를 사용하여 이 문제를 해결해야 한다.
- ORM은 일반적인 안전성과 타입 안전성을 기본으로 제공하는 고수준 API이다. 그러니 데이터베이스를 사용할 때 항상 ORM을 사용하자.
  - 일반적인 안전성: SQL 주입 공격 등을 방지 가능
  - 타입 안전성: 예시) 수동으로 타입을 지정하지 않아도 `findOne`이 어떤 타입을 반환할지 알 수 있음

### 9.4 마치며

- 자바스크립트 프레임워크는 빠르게 변화하기 때문에 9장을 통해 얻은 직관력을 응용하여 타입 안전 프레임워크로 어떤 문제를 해결하는지 파악하고, 어떤 프레임워크를 정확히 어디에 접목하여 코드를 더 안전하고, 더 잘 추상화하고, 모듈화할 수 있는지 알아내야 한다.
