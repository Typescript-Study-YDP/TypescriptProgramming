# 내용 정리

## 8장. 비동기 프로그래밍, 동시성과 병렬성

- 스레드 하나로 비동기 작업을 처리하는 **이벤트 루프**가 바로 자바스크립트 엔진의 표준 모델이다.(211)
- 자바스크립트는 이벤트 루프 기반의 동시성 모델을 이용해 멀티스레드 기반 프로그래밍에서 공통적으로 나타나는 문제점을 해결한다.(211)
  - 문제점: 동기화된 데이터 타입의 오버헤드, 뮤텍스(mutex), 세마포어(semaphore), 기타 멀티스레딩의 골칫거리 등.

### 8.1 자바스크립트의 이벤트 루프

![이벤트 루프](https://file.notion.so/f/f/84db2a13-c51e-4c10-8239-1d5b88042ee5/c039947c-3bab-463e-bb77-4c54da47c86e/Untitled.png?id=6c686cce-9d60-4a3b-8fce-b233fd9eca39&table=block&spaceId=84db2a13-c51e-4c10-8239-1d5b88042ee5&expirationTimestamp=1705795200000&signature=06o_i3158Eiuh773fXZkSu4GjjdGo71Eda4c80v5blU&downloadName=Untitled.png)

- 간략한 설명

  - 자바스크립트 엔진, Web API, 태스크 큐로 구성되어 있다.
  - 자바스크립트 엔진은 Heap과 Call Stack으로 나눠져있다.
    - **Heap**은 메모리를 관리하는 곳으로 변수와 객체의 메모리 할당이 이루어진다.
    - **Call Stack**은 코드 실행을 관리하며, 코드가 실행될 때 호출 스택이 Stack의 형태로 쌓인다.
  - 일반적인 작업은 콜스택(Call Stack)에서 이루어집니다.
  - 시간이 소요되는 작업들(setTimeout, 이벤트, HTTP 요청 메서드 등)은 WebAPI에서 대기하다가 콜백 큐(Callback Queue)로 보내집니다.
  - Call Stack이 비워져 있을때만 Callback Queue에 저장되어있던 작업들을 Call Stack으로 보냅니다.

- 자세한 동작원리(213)
  1. 메인 자바스크립트 스레드는 `XMLHTTPRequest`(AJAX 요청), `setTimeout`(잠자기), `readFile`(디스크에서 파일 읽기) 등의 네이티브 비동기 API를 호출한다.
     - 위 API들은 자바스크립트 플랫폼에서 제공하며 직접 만들 수 없다.(다만 브라우저 플랫폼을 포크하거나 C++용 NodeJS를 확장하면 가능)
  2. 네이티브 비동기를 호출한 이후에 다시 메인 스레드로 제어가 반환되며 마지막 실행됐던 지점부터 코드가 다시 실행된다.
  3. 비동기 작업이 완료되면 플랫폼은 태스크를 이벤트 큐에 추가한다.
     각 스레드가 자신만의 큐를 가지고 있으며, 이를 이용해 비동기 연산 결과를 메인 스레드로 전달한다.
     태스크에는 호출 자체와 관련한 메타 정보 일부와 메인 스레드에 연결된 콜백 함수의 참조가 들어 있다.
  4. 메인 스레드의 콜 스택이 비면 플랫폼은 이벤트 큐에 남아 있는 태스크가 있는지 확인한다.
     대기 중인 태스크가 있으면 플랫폼은 그 태스크를 실행한다. 이때 함수 호출이 일어나며 제어는 메인 스레드 함수로 반환된다.
     함수 호출이 끝나고 콜스택이 다시 비면 플랫폼은 다시 기다리는 태스크가 있는지 이벤트 큐에서 확인한다.
     콜 스택과 이벤트 큐가 모두 비고, 모든 비동기 네이티브 API 호출이 완료될 때까지 이 과정을 반복한다.

### 8.2 콜백 사용하기

- 비동기 자바스크립트 프로그램의 기본 단위는 콜백(callback)이다.(214)

  - 콜백은 평범한 함수로, 다른 함수의 인수 형태로 전달된다.

    ```javascript
    const array = [1, 4, 9, 16];

    const map = array.map((x) => x * 2); // [2, 8, 18, 32]
    ```

- 하지만 이런 콜백 방식은 연달아 수행되는 작업을 코드로 표현하기 어려운 문제가 있다.(216)
  ![콜백 지옥 or 콜백 피라미드](https://www.google.com/url?sa=i&url=https%3A%2F%2Fhanamon.kr%2Fjavascript-%25EC%25BD%259C%25EB%25B0%25B1-%25EC%25A7%2580%25EC%2598%25A5-%25ED%2583%2588%25EC%25B6%259C%25ED%2595%2598%25EA%25B8%25B0-%25EB%25B9%2584%25EB%258F%2599%25EA%25B8%25B0-%25EC%25B2%2598%25EB%25A6%25AC-%25EB%25B0%25A9%25EB%25B2%2595%2F&psig=AOvVaw0mQgrFmRfjZzvlyWL8nM7L&ust=1705733762401000&source=images&cd=vfe&opi=89978449&ved=0CBIQjRxqFwoTCJCGl8rv6IMDFQAAAAAdAAAAABAD)

- 여러 동작을 연달아 실행할 때 보통 한 동작이 성공했을 때만 다음 동작으로 이어가고, 에러가 발생하면 즉시 빠져나와야 할 때가 많다. 콜백을 이용하면 이런 제어를 수동으로 처리해야 한다.(217)
- 비동기 동작 여러 개를 이어 붙이는 것도 유용하지만, 때로는 함수들을 병렬로 실행시킨 후 모두가 완료됐을 때 통지하도록 하거나, 서로 경쟁시켜 가장 먼저 끝난 작업 결과를 이용하는 등의 방식으로 활용할 수도 있다.(217)

#### 요약

1. 간단한 비동기 작업에는 콜백을 사용한다.
2. 다만, 콜백은 비동기 작업이 여러 개로 늘어나면 금방 복잡해진다.

### 8.3 프로미스로 정상 회복하기

- Promise는 **비동기 작업의 완료 또는 실패와 같은 결과를 나타내는 객체**이다.
- 주로 콜백 지옥(callback hell)을 해결하기 위해 사용된다.
- `new Promise(executor)`를 통해 생성되며, 실행자(executor) 함수는 resolve와 reject를 인자로 받는다.
- `then` 및 `catch` 메서드를 사용하여 성공 또는 실패 시 수행할 작업을 정의할 수 있다.

  - 한 작업이 성공하면 다음 작업을 실행하며, 그 중 하나가 실패하면 곧장 catch 절로 직행한다.(218)

  ```javascript
  const myPromise = new Promise((resolve, reject) => {
    // 비동기 작업 수행
    if (작업이 성공적) {
      resolve(결과);
    } else {
      reject(에러);
    }
  });

  myPromise.then((result) => {
    // 성공 시 처리
  }).catch((error) => {
    // 실패 시 처리
  });
  ```

- resolve 매개변수 타입은 우리가 어떤 API를 사용하는지에 따라 달라진다.(220)
  - 아래 예제에서는 result 타입이 매개변수의 타입이 된다.
- reject의 매개변수 타입은 항상 Error 유형이 된다.

  ```typescript
  type Executor<T, E extends Error> = (
    resolve: (result: T) => void,
    reject: (error: E) => void,
  ) => void;
  ```

### 8.4 async와 await

- **`async` 함수는 비동기 작업을 수행하고, 그 결과를 `Promise`로 반환하는 함수**이다.
- `async` 키워드로 함수를 선언하고, 내부에서 `await` 키워드를 사용하여 Promise가 완료될 때까지 기다린다.
- 코드가 동기적으로 보이도록 작성할 수 있어 가독성이 좋아진다.
  → 프로미스의 then, catch, finally와 같은 후속 처리 메서드에 콜백함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기처리처럼 프로미스가 처리 결과를 반환하도록 할 수 있기 때문.
- `finally`는 then과 catch를 실행한 다음 최후로 실행되는 구문이다.(223)

  ```javascript
  // before
  function getUser() {
    getUserID(18)
      .then(user => getLocation(user))
      .then(location => console.info('위치 가져옴!, location))
      .catch(error => console.error(error))
      .finally(()=> console.info('위치 가져오기 완료!));
  }

  // after
  async function getUser() {
    try {
      let user = await getUserID(18);
      let location = await getLocation(user);
      console.info('위치 가져옴!, location);
    } catch (error) {
      console.error(error);
    } finally {
      console.info('위치 가져오기 완료!);
    }
  }
  ```

### 8.5 비동기 스트림

- 만약 미래의 서로 다른 시점에 이용할 수 있게 될 값이 여러 개라면 어떻게 처리해야할까?(224)
  - 예시
    - 파일 시스템에서 파일의 일부를 읽는 상황
    - 넷플릭스 서버로부터 비디오 스트리밍의 픽셀들을 받는 상황
    - 폼을 작성하느라 여러 키를 입력하는 상황
    - 저녁 파티에 여러 명의 친구가 오는 상황
    - 선거 시 부재자 투표가 이루어지는 상황
- 가장 흔히 NodeJS의 EventEmitter 같은 이벤트 방출기(event emitter)를 이용하거나 RxJS 같은 리액티브 프로그래밍 라이브러리를 사용한다.(224)
  - 두 방식의 차이는 콜백과 프로미스의 관계와 비슷하다. 이벤트 방출기는 빠르고 가벼운 반면, 리액티브 프로그래밍 라이브러리는 더 강력하며 이벤트 스트림을 조합하고 연결하는 기능을 제공한다.

### 8.6 타입 안전 멀티스레딩

- 때로는 CPU를 많이 사용하는 작업이 필요해진다.(229)
  - 진정한 병렬성, 즉 작업을 여러 개의 스레드로 분리해서 속도를 높이거나 메인 스레드의 부하를 줄여 반응성을 높여야 할 때가 있다.
- 이럴 때는 브라우저와 서버에서 안전하게 병렬 프로그램을 구현하는 패턴을 사용하여 해결한다.
  1. 브라우저에서 웹 워커 활용하기(229~239)
  2. NodeJS에서 자식 프로세스 이용하기(240~241)
